\documentclass{scrartcl}
\usepackage{listings}
\usepackage{caption}
\usepackage{color}
\usepackage{booktabs}
\usepackage{lscape}
\usepackage{tabularx}

\newcounter{nalg}[section] % defines algorithm counter for section
\renewcommand{\thenalg}{\thesection .\arabic{nalg}} %defines appearance of the algorithm counter
\DeclareCaptionLabelFormat{algocaption}{Algorithm \thenalg} % defines a new caption label as Algorithm x.y

\lstnewenvironment{algorithm}[1][] %defines the algorithm listing environment
{   
    \refstepcounter{nalg} %increments algorithm number
    \captionsetup{labelformat=algocaption,labelsep=colon} %defines the
                                                          %caption
                                                          %setup for:
                                                          %it ises
                                                          %label
                                                          %format as
                                                          %the
                                                          %declared
                                                          %caption
                                                          %label above
                                                          %and makes
                                                          %label and
                                                          %caption
                                                          %text to be
                                                          %separated
                                                          %by a ':'
    \lstset{ %this is the stype
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        basicstyle=\scriptsize, 
        keywordstyle=\color{black}\bfseries,
        escapeinside={(*}{*)},
        keywords={,input, output, return, datatype, function, in, if, else, foreach, while, begin, end, } 
        numbers=left,
        xleftmargin=.04\textwidth,
        #1 % this is to add specific settings to an usage of this environment (for instnce, the caption and referable label)
    }
}
{}





\author{Alexander Eisl (0250266), Peter Wiedermann (0025999)}

\date{\today}


\title{Heuristic Optimization Techniques \\ Exercise 2}

\begin{document}
\maketitle


\section{Local Search}
\label{sec:deterministic}
In this programming exercise, we improve the results of the
construction heuristic developed in the previous exercise by using a
local search. In the following subsection, we will first explain the
neighborhoods that we define and then outline the step functions used.

%%% brauchen wir sowas?
\begin{algorithm}[caption={Local search}]
    input: Graph 
    output: Improved solution
    begin
    	sol (*$\leftarrow$*) calculate initial solution
	repeat:
		choose sol' (*$\in$*) N(x) 
		if (*$f(sol')$*) (*$\leq$*) f(sol) then
			sol (*$\leftarrow$*) sol'
	until stopping criteria satisfied
    end
\end{algorithm}


%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%%% NEIGHBORHOODS HERE
\subsection{Neighborhoods}
\label{neighborhoods}
We use the following neighbourhoods:

\begin{description}
\item[1-node flip] 
    
    This neighbourhood is defined as all subsets where two vertices of the initial solution are flipped. 
    \begin{itemize}
        \item Size of neigborhood: $n(n-1)/2$
        \item Objective Function: Very intensive because we change the spine order.

    \end{itemize}

    Combination of big neigborhood size and complex objective function makes this  a omputationally intensive variant.
    However, we expect this to give large improvements at least for small graphs.

	
\item[1-edge move] This neighbourhood consists of all solutions where one edge is moved to a different page. 
     \begin{itemize}
        \item Size of neigborhood: $(pages-1) edges$ 
        \item Objective Function: Incremental, only crossings for moved edges are recalculated.
    \end{itemize}
   
    The incremental objective function and the moderat neighborhood size makes this variant computational feasible.

    TODO: number of steps to reach local optimum
	
\item[1-node edge move] This neighbourhood consists of all solutions where the edges of
	one vertex on a specific page are moved to all different pages. 

    \begin{itemize}
        \item Size of neigborhood: $(pages-1) edges$ as worst case \footnote{depending on number of edges on respective node pages}.
        \item Objective Function: Incremental, only crossings for moved edges are recalculated.
    \end{itemize}
    
    This also allows for incremental neighbourhoods, the
		size is $(pages-1) |N(v_i)|$

\end{description}

%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%%% STEPFUNCTIONS HERE
\subsection{Stepfunctions}

We implemented the following thre stepfunctions:

\begin{description}
\item[first] This step-function selects the first better solution found in the neighborhood.
\item[best] This step-function iterates over all elements of the neighbourhood and chooses the best one.
\item[random] This step-function selects a random element of the neighbourhood. 
\end{description}


%%% REMOVED, I don't think this is necessary
%%\section{Solution Representation}
%%The same as in exercise 1. Do we need this subsection?


%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%%% NEIGHBORHOODS HERE
\section{Results}
We executed the code on a desktop computer with a Core i7 Quad-Core
CPU with 2.67Ghz and 24 GB of main memory. Table~\ref{tab:results}
shows the results of our local search. 


\paragraph{Best neighborhood step function strategy}
We compare the results for
three different neighboorhoods and all the implemented step-functions.
Overall, the combination of the 1-node-flip neighborhood and the best
step-function shows the best improvements. For example, it finds a
solution with only $12$ edge-crossings for the instance automatic-4.
Not surprisingly, it also has the highest run-time.

\paragraph{Initial Solution}
It is important to use a good initial solution. First, because this
helps to end up in a good local solution.\footnote{For example, the
  results shown on the AC cluster indicate that it should be possible
  to find a solution with zero crossings. However, our local solution
  is not able to find them given the initial solutions provided by our
  construction heuristic.} Second, it can reduce the run-time of the
algorithm because it might reduce the number of steps taken to reach
the local optimum.

When we compare the results with a random initial solution we could
measure an avg increase of XXX crossings 
\footnote{measured with 1-node flip and best stepfunction}.

\paragraph{Reaching local optimum}


%% Q1: Does using a good initial solution help? \\
%% A1: It's very important to have a good initial solution. First, because it helps to end up
%% in a good local optimum. Second, because it significantly reduces the run-time of the algorithm.

%% TODO: wo steht Q1?

%% Does it yield a gain if compared to simply using random initial solutions?
%% TODO: Use 1-node-flip and best stepfunction to answer this question because it should show the best effect

%% TODO: ??? Ich glaub da verstehen wir die Frage unterschiedlich


%% Q2: Can subsequent (possibly random) moves in your neighbourhood(s) reach
%% any valid solution in the search space?
%% A2: 
Some notes about our neighborhoods:

\begin{itemize}
  \item For many graphs, we do not find an improvement. So with respect to our neighborhood we
  seem to be in a local optimum. 
  \item It seems to be important to use the ``best''
    step-function. Iteratively using the ``first'' does not yield the
    same optimum. Once we choose an element of the neighborhood, other
    neighbors of the initial neighborhood cannot be reached
    anymore.\footnote{This seems intuitiv given the definitions of our
      neighborhood}
\end{itemize}



%% Q3: How many iterations does it take to reach local optima? What does this say about your neighbourhood(s)?

%% Q4: How does incremental evaluation work for your neighbourhoods?
%% see description of neigborhoods in section \ref{neighborhoods}.


\begin{landscape}
\begin{table}
  \scriptsize
  \input{resultsTab}
\caption{This table shows the results of our local search. For each instance, we show the number of crossings (first row), the iteration 
needed to reach the local optimum (second row, first value) and the run-time of our algorithm (second row, second value).}
\label{tab:results}
\end{table}
\end{landscape}



\end{document}
